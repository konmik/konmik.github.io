<!DOCTYPE html>
<html lang="en-us">
<head>
<meta charset="utf-8">
<meta name="description" content="">
<meta name="keywords" content="">
<meta name="author" content="">
<meta name="generator" content="Hugo 0.17" />
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400,700" type="text/css">
<link rel="alternate" href="/index.xml" type="application/rss+xml" title="Konstantin Mikheev&#39;s programming blog">
<title>Snorkeling with Dagger 2 - Konstantin Mikheev&#39;s programming blog</title>
</head>
<body>

<header>
  <div class="container clearfix">
    <a class="path" href="http://konmik.com">[Konstantin Mikheev&#39;s programming blog]</a>

    <div class="right">
      
    </div>
  </div>
</header>

<div class="container">


<main role="main" class="article">
  
<article class="single" itemscope itemtype="http://schema.org/BlogPosting">
  <div class="meta">

    <span class="key">published on</span>
    <span class="val"><time itemprop="datePublished" datetime="2015-02-01">February 01, 2015</time></span>



    <br>
    <span class="key">tags:</span>
    <span class="val">

        <a href="tags/java">Java</a>

        <a href="tags/android">Android</a>

    </span>

  </div>
  <h1 class="headline" itemprop="headline">Snorkeling with Dagger 2</h1>
  <section class="body" itemprop="articleBody">
    <p>Dagger is a popular library for Java, it makes writing code much easier and more structured.
In this article I will describe how can we benefit of using it,
show some simple use cases and explore the generated code.
As a bonus, I will show an advanced trick that makes Dagger 2 much more flexible.</p>

<p></p>

<h1 id="introduction-what-the-hell-is-dagger-and-how-can-i-benefit-of-using-it">Introduction: what the hell is Dagger and how can I benefit of using it?</h1>

<h2 id="what-is-dagger">What is Dagger</h2>

<p>Dagger is a java library that provides an alternative way for objects instantiation.
Instead of passing one zillion of arguments with constructor you can just
annotate your fields with <code>@Inject</code> annotation and all required objects will
be created and assigned automatically.</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span>    <span class="nd">@Inject</span> <span class="n">SharedPreferences</span> <span class="n">pref</span><span class="o">;</span>
</code></pre></div>

<p>This is done by a source code generation - you annotate some fields, Dagger will create some code that will fill that fields.
You can always check the generated code in the <code>build</code> folder.</p>

<p>Think of Dagger as of a Java language extension.
While normally object-oriented languages have a lots of problems with objects creation,
storage and passing them around, Dagger provides an elegant solution.</p>

<h3 id="history">History</h3>

<p>Dagger has been developed by <em>Square, Inc</em> guys:
<a href="http://square.github.io/dagger/">square.github.io/dagger</a></p>

<p>Dagger 2 is a fork of Square&rsquo;s Dagger that has been developed by <em>Google</em>
and has been used on performance critical projects:
<a href="https://github.com/google/dagger">github.com/google/dagger</a></p>

<h2 id="benefits-singleton">Benefits: Singleton</h2>

<p>On Android one of the typical tasks is to create a single <code>SharedPreferences</code> object and share it through all the application.
It is required in an activity, in a fragment, in a custom view. Typical solution is to keep that <code>SharedPreference</code> inside of <code>Application</code> object
and create a getter for it. Then, your code will look like this:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MainActivity</span> <span class="kd">extends</span> <span class="n">Activity</span> <span class="o">{</span>
    <span class="n">SharedPreferences</span> <span class="n">pref</span><span class="o">;</span>
    <span class="n">Gson</span> <span class="n">gson</span><span class="o">;</span>
    <span class="n">ServerAPI</span> <span class="n">api</span><span class="o">;</span>

    <span class="n">onCreate</span><span class="o">(...)</span> <span class="o">{</span>
        <span class="n">MyApp</span> <span class="n">app</span> <span class="o">=</span> <span class="o">(</span><span class="n">MyApp</span><span class="o">)</span><span class="n">getContext</span><span class="o">().</span><span class="na">getApplicationContext</span><span class="o">();</span>
        <span class="n">pref</span> <span class="o">=</span> <span class="n">app</span><span class="o">.</span><span class="na">getSharedPreferences</span><span class="o">();</span>
        <span class="n">gson</span> <span class="o">=</span> <span class="n">app</span><span class="o">.</span><span class="na">getGson</span><span class="o">();</span>
        <span class="n">api</span> <span class="o">=</span> <span class="n">app</span><span class="o">.</span><span class="na">getApi</span><span class="o">();</span>
</code></pre></div>

<p>One day you will find that <code>MyApp</code> is bloated with stranger things that have no any relevance to <code>MyApp</code>. Or you may find yourself using ugly
Singleton pattern everywhere. Now, think about refactoring. You&rsquo;ve decided to move <code>Gson</code> away from <code>MyApp</code> into <code>MyNetwork</code>.
How many lines of code you will need to change?</p>

<p>Dagger way:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MainActivity</span> <span class="kd">extends</span> <span class="n">Activity</span> <span class="o">{</span>
    <span class="nd">@Inject</span> <span class="n">SharedPreferences</span> <span class="n">pref</span><span class="o">;</span>
    <span class="nd">@Inject</span> <span class="n">Gson</span> <span class="n">gson</span><span class="o">;</span>
    <span class="nd">@Inject</span> <span class="n">ServerAPI</span> <span class="n">api</span><span class="o">;</span>

    <span class="n">onCreate</span><span class="o">(...)</span> <span class="o">{</span>
        <span class="n">MainInjector</span><span class="o">.</span><span class="na">inject</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
</code></pre></div>

<p>Now we do not care about where to get all that stuff - it will be created for us. <code>Gson</code> could be inside of <code>MyApp</code> object.
It also could be somewhere in <code>MyNetwork.Parsing.Processor</code>. We just require <code>Gson</code>! Yes, we need to instruct Dagger how to get <code>Gson</code> once,
but later we will be able to share it all over the application with <code>@Inject</code> annotation.</p>

<h2 id="benefits-order-of-objects-instantiation">Benefits: Order of objects instantiation</h2>

<p>Another problem we have is the order of objects instantiation. Say, we have
<code>ServerAPI</code>, <code>Gson</code>, <code>DateConverter</code>, <code>AuthenticationManager</code>, <code>SharedPreferences</code> and 50 other objects that we need to initialize.
One day we&rsquo;ve decided to make some refactoring, and we&rsquo;ve lost track of what should be initialized in which order.
Null pointer exceptions everywhere! Stack overflow because of circular constructor calls! What have I done? <code>git reset --hard</code>!
But Dagger manages the order of objects instantiation and warns you about such problems during compile-time.</p>

<h2 id="benefits-passing-constructor-arguments-that-are-not-required-for-the-object">Benefits: Passing constructor arguments that are not required for the object</h2>

<p>How about this example?</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="n">onCreate</span><span class="o">(..)</span> <span class="o">{</span>
    <span class="n">authManager</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AuthManager</span><span class="o">(((</span><span class="n">MyApp</span><span class="o">)</span><span class="n">getContext</span><span class="o">().</span><span class="na">getApplicationContext</span><span class="o">()).</span><span class="na">getGson</span><span class="o">());</span>

<span class="n">AuthManager</span><span class="o">(</span><span class="n">Gson</span> <span class="n">gson</span><span class="o">,</span> <span class="n">SharedPreferences</span> <span class="n">pref</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">new</span> <span class="n">Network</span><span class="o">(</span><span class="n">gson</span><span class="o">,</span> <span class="n">pref</span><span class="o">,</span> <span class="n">serverTokenProvider</span><span class="o">);</span>

<span class="n">Network</span><span class="o">(</span><span class="n">Gson</span> <span class="n">gson</span><span class="o">,</span> <span class="n">SharedPreferences</span> <span class="n">pref</span><span class="o">,</span> <span class="n">ServerTokenProvider</span> <span class="n">tokenProvider</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">super</span><span class="o">(</span><span class="n">tokenProvider</span><span class="o">)</span>
    <span class="k">new</span> <span class="n">ServerAPI</span><span class="o">(</span><span class="n">gson</span><span class="o">,</span> <span class="n">pref</span><span class="o">,</span> <span class="n">tokenProvider</span><span class="o">);</span>

<span class="n">ServerAPI</span><span class="o">(</span><span class="n">Gson</span> <span class="n">gson</span><span class="o">,</span> <span class="n">SharedPreferences</span> <span class="n">pref</span><span class="o">,</span> <span class="n">ServerTokenProvider</span> <span class="n">tokenProvider</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">new</span> <span class="n">RestAdapter</span><span class="o">(</span><span class="n">gson</span><span class="o">);</span> <span class="c1">// Finally!</span>
</code></pre></div>

<p>Dagger way:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="kd">class</span> <span class="nc">ServerAPI</span> <span class="o">{</span>
    <span class="nd">@Inject</span> <span class="n">SharedPreferences</span> <span class="n">pref</span><span class="o">;</span>
    <span class="nd">@Inject</span> <span class="n">Gson</span> <span class="n">gson</span><span class="o">;</span>
    <span class="nd">@Inject</span> <span class="n">ServerTokenProvider</span> <span class="n">tokenProvider</span><span class="o">;</span>
</code></pre></div>

<p>Or even better:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="kd">class</span> <span class="nc">ServerAPI</span> <span class="o">{</span>
    <span class="nd">@Inject</span> <span class="n">RestAdapter</span> <span class="n">restAdapter</span><span class="o">;</span>
</code></pre></div>

<h2 id="other-benefits">Other benefits</h2>

<h3 id="unit-tests">Unit tests</h3>

<p>With Dagger it is very easy to inject one object instead of another for the sake of unit-testing.</p>

<h3 id="integration-tests">Integration tests</h3>

<p>You can easily substitute any part of your application. In example, you can inject a network interface that will provide
an application with mock data, failure responses and delays to simulate poor network connection and incorrect server responses.</p>

<p>Here is an example: <a href="https://github.com/JakeWharton/u2020">U+2020</a></p>

<h3 id="scopes">Scopes</h3>

<p>With Dagger injections can be bound to a specific part of an application. In example, you can inject activity-related
objects such as <code>DrawerController</code> and <code>ActionBarController</code> and when an activity dies, you can automatically release references
to objects inside Dagger that have been associated with this activity, so sharing of activity-related objects can be done without memory leaks.</p>

<p>Another example is to hide all authentication-related objects (a network cache, a balance, an access token) when user logs out,
so all successive activities will get fresh objects in unauthenticated state.</p>

<h3 id="objects-decoupling">Objects decoupling</h3>

<p>It is hard to build a multi-object environment where all components are tightly coupled. In example,
if every component that has access to <code>SharedPreferences</code> should know how to create <code>SharedPreferences</code> instance
or where to get it then if something changes you should trace all objects that are using
<code>SharedPreferences</code> and change their behavior. With Dagger the code that initializes <code>SharedPreferences</code>
lives in a different place of where <code>SharedPreferences</code> are used. So there are less connections between
objects and refactoring can be made easy.</p>

<h3 id="declarative-programming-style">Declarative programming style</h3>

<p><em>Declarative programming</em> means that when you&rsquo;re writing a program you&rsquo;re declaring what is going on,
rather than how this code is connected with other parts of your program and what is going next. Amount of bugs that can
be avoided with the declarative programming style is tremendous. On Android it is not easy to understand how
this could be done because we have so many callbacks and lifecycles that needs to be taken into account,
but Dagger helps at least with the objects instantiation.</p>

<h1 id="installation">Installation</h1>

<p>Dagger consists of two parts - a compiler that will generate the injection code and a very little runtime library.</p>

<p>You will also need to include that two <code>javax.*</code> additional libraries Dagger 2 depends on.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>dependencies {
    compile &#39;javax.inject:javax.inject:1&#39;
    compile &#39;javax.annotation:javax.annotation-api:1.2&#39;
    compile &#39;com.google.dagger:dagger:2.0&#39;
    provided &#39;com.google.dagger:dagger-compiler:2.0&#39;
}
</code></pre></div>

<h1 id="basic-example">Basic example</h1>

<hr />

<h2 id="simple-injection-with-inject-constructor">Simple injection with @Inject constructor</h2>

<p>Let&rsquo;s create a simplest possible example. We will inject <code>PreferencesLogger</code> - an object that will log all <code>SharedPreferences</code> values.</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">PreferencesLogger</span> <span class="o">{</span>

    <span class="nd">@Inject</span>
    <span class="kd">public</span> <span class="nf">PreferencesLogger</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">log</span><span class="o">(</span><span class="n">Context</span> <span class="n">context</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">SharedPreferences</span> <span class="n">pref</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">getSharedPreferences</span><span class="o">(</span><span class="s">&quot;preferences&quot;</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>

        <span class="n">Log</span><span class="o">.</span><span class="na">v</span><span class="o">(</span><span class="n">getClass</span><span class="o">().</span><span class="na">getSimpleName</span><span class="o">(),</span> <span class="s">&quot;Logging all preferences:&quot;</span><span class="o">);</span>

        <span class="k">for</span> <span class="o">(</span><span class="n">Map</span><span class="o">.</span><span class="na">Entry</span> <span class="n">entry</span> <span class="o">:</span> <span class="n">pref</span><span class="o">.</span><span class="na">getAll</span><span class="o">().</span><span class="na">entrySet</span><span class="o">())</span>
            <span class="n">Log</span><span class="o">.</span><span class="na">v</span><span class="o">(</span><span class="n">getClass</span><span class="o">().</span><span class="na">getSimpleName</span><span class="o">(),</span> <span class="n">entry</span><span class="o">.</span><span class="na">getKey</span><span class="o">()</span> <span class="o">+</span> <span class="s">&quot; = &quot;</span> <span class="o">+</span> <span class="n">entry</span><span class="o">.</span><span class="na">getValue</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>

<p><code>@Inject</code> says to Dagger that this constructor will be used to instantiate <code>PreferencesLogger</code> object. The current implementation
is quite stupid but we will make <code>SharedPreferences</code> to be passed to the <code>PreferencesLogger</code>&rsquo;s constructor later and it will look a little bit better.</p>

<h2 id="injection">Injection</h2>

<p>Here is how we want to use <code>PreferencesLogger</code>:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MainActivity</span> <span class="kd">extends</span> <span class="n">Activity</span> <span class="o">{</span>
    <span class="nd">@Inject</span> <span class="n">PreferencesLogger</span> <span class="n">logger</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="o">(</span><span class="n">Bundle</span> <span class="n">savedInstanceState</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">(</span><span class="n">savedInstanceState</span><span class="o">);</span>

        <span class="n">MyApplication</span><span class="o">.</span><span class="na">inject</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>

        <span class="n">logger</span><span class="o">.</span><span class="na">log</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>

<h2 id="code-generation">Code generation</h2>

<p>Are you curious how <code>MyApplication.inject</code> looks like? No, you can&rsquo;t see it right now. :D At first you need to see a little picture.</p>

<p><img src="/images/dagger_2_diagram_1.png" alt="Dagger 2 diagram 1" /></p>

<p>While working with Dagger 2, we need to keep in mind how it is composed. You know about <code>@Inject</code> constructor, so next
thing to know about is <code>@Component</code>. Component is an interface marked with <code>@Component</code> annotation that shows
to Dagger 2 into which objects we want to inject.</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">AppComponent</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">inject</span><span class="o">(</span><span class="n">MainActivity</span> <span class="n">activity</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div>

<p><code>@Component</code> says to Dagger 2 that it should generate code for injection into <code>MainActivity</code>.</p>

<p>After we wrote all this, we press <code>Build</code> button to make Dagger 2 generate an <code>AppComponent</code> implementation.</p>

<h2 id="finally-the-injection-code">Finally: the injection code</h2>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyApplication</span> <span class="kd">extends</span> <span class="n">Application</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="n">AppComponent</span> <span class="n">component</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">();</span>
        <span class="n">component</span> <span class="o">=</span> <span class="n">DaggerAppComponent</span><span class="o">.</span><span class="na">builder</span><span class="o">().</span><span class="na">build</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">inject</span><span class="o">(</span><span class="n">MainActivity</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">component</span><span class="o">.</span><span class="na">inject</span><span class="o">(</span><span class="n">target</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>

<p><code>DaggerAppComponent</code> is a generated class of type <code>AppComponent</code> that we need to access the generated code.
The IDE can not see this generated class and marks it as red, but later I will show how to deal with this problem.</p>

<p>Now we have a complete workable example! :)</p>

<p>Yes, Dagger requires a little bit of work to do at the beginning. But think about advantages it can give!
On my average project I have about 50 objects that need to be shared across an application.
Amount of code rewrites Dagger saves for me is incredible! Before Dagger I always avoided refactoring whenever possible.
Now I refactor quickly and easily, without side-effects or broken connections between objects.</p>

<p>I hope you&rsquo;re still alive at this point. If so, let&rsquo;s study some advanced topics.</p>

<h1 id="exploring-the-generated-code">Exploring the generated code</h1>

<p>Let&rsquo;s take a look at what has been generated. I&rsquo;ve stripped out all code that does nothing, to not bloat this quickie guide. :)</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">DaggerAppComponent</span> <span class="kd">implements</span> <span class="n">AppComponent</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">MembersInjector</span> <span class="n">mainActivityMembersInjector</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nf">DaggerAppComponent</span><span class="o">(</span><span class="n">Builder</span> <span class="n">builder</span><span class="o">)</span> <span class="o">{</span>
<span class="o">(</span><span class="mi">3</span><span class="o">)</span>     <span class="n">initialize</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Builder</span> <span class="nf">builder</span><span class="o">()</span> <span class="o">{</span>
<span class="o">(</span><span class="mi">1</span><span class="o">)</span>    <span class="k">return</span> <span class="k">new</span> <span class="n">Builder</span><span class="o">();</span> <span class="c1">// Builder instantiation</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">initialize</span><span class="o">()</span> <span class="o">{</span>
<span class="o">(</span><span class="mi">4</span><span class="o">)</span>    <span class="k">this</span><span class="o">.</span><span class="na">mainActivityMembersInjector</span> <span class="o">=</span> <span class="n">MainActivity_MembersInjector</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="n">MembersInjectors</span><span class="o">.</span><span class="na">noOp</span><span class="o">(),</span> <span class="n">PreferencesLogger_Factory</span><span class="o">.</span><span class="na">create</span><span class="o">());</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">inject</span><span class="o">(</span><span class="n">MainActivity</span> <span class="n">activity</span><span class="o">)</span> <span class="o">{</span>
<span class="o">(</span><span class="mi">9</span><span class="o">)</span>   <span class="n">mainActivityMembersInjector</span><span class="o">.</span><span class="na">injectMembers</span><span class="o">(</span><span class="n">activity</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Builder</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="n">AppComponent</span> <span class="nf">build</span><span class="o">()</span> <span class="o">{</span>
<span class="o">(</span><span class="mi">2</span><span class="o">)</span>        <span class="k">return</span> <span class="k">new</span> <span class="n">DaggerAppComponent</span><span class="o">(</span><span class="k">this</span><span class="o">);</span> <span class="c1">// DaggerAppComponent instantiation</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">MainActivity_MembersInjector</span> <span class="kd">implements</span> <span class="n">MembersInjector</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">MembersInjector</span> <span class="n">supertypeInjector</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Provider</span> <span class="n">loggerProvider</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">MainActivity_MembersInjector</span><span class="o">(</span><span class="n">MembersInjector</span> <span class="n">supertypeInjector</span><span class="o">,</span> <span class="n">Provider</span> <span class="n">loggerProvider</span><span class="o">)</span> <span class="o">{</span>
<span class="o">(</span><span class="mi">7</span><span class="o">)</span>     <span class="k">this</span><span class="o">.</span><span class="na">supertypeInjector</span> <span class="o">=</span> <span class="n">supertypeInjector</span><span class="o">;</span>
<span class="o">(</span><span class="mi">8</span><span class="o">)</span>     <span class="k">this</span><span class="o">.</span><span class="na">loggerProvider</span> <span class="o">=</span> <span class="n">loggerProvider</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">injectMembers</span><span class="o">(</span><span class="n">MainActivity</span> <span class="n">instance</span><span class="o">)</span> <span class="o">{</span>
<span class="o">(</span><span class="mi">10</span><span class="o">)</span>   <span class="n">supertypeInjector</span><span class="o">.</span><span class="na">injectMembers</span><span class="o">(</span><span class="n">instance</span><span class="o">);</span>
<span class="o">(</span><span class="mi">11</span><span class="o">)</span>   <span class="n">instance</span><span class="o">.</span><span class="na">logger</span> <span class="o">=</span> <span class="n">loggerProvider</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="n">MembersInjector</span> <span class="nf">create</span><span class="o">(</span><span class="n">MembersInjector</span> <span class="n">supertypeInjector</span><span class="o">,</span> <span class="n">Provider</span> <span class="n">loggerProvider</span><span class="o">)</span> <span class="o">{</span>
<span class="o">(</span><span class="mi">6</span><span class="o">)</span>  <span class="k">return</span> <span class="k">new</span> <span class="n">MainActivity_MembersInjector</span><span class="o">(</span><span class="n">supertypeInjector</span><span class="o">,</span> <span class="n">loggerProvider</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">enum</span> <span class="n">PreferencesLogger_Factory</span> <span class="kd">implements</span> <span class="n">Factory</span> <span class="o">{</span>
    <span class="n">INSTANCE</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">PreferencesLogger</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span>
<span class="o">(</span><span class="mi">12</span><span class="o">)</span>   <span class="k">return</span> <span class="k">new</span> <span class="n">PreferencesLogger</span><span class="o">();</span> <span class="c1">// @Inject annotated constructor call</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Factory</span> <span class="nf">create</span><span class="o">()</span> <span class="o">{</span>
<span class="o">(</span><span class="mi">5</span><span class="o">)</span>    <span class="k">return</span> <span class="n">INSTANCE</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>

<p>No comments has been generated but it is quite obvious how this simple code works.
I&rsquo;ll just put here some referenced code that can confuse by its absence.</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Factory</span>  <span class="kd">extends</span> <span class="n">javax</span><span class="o">.</span><span class="na">inject</span><span class="o">.</span><span class="na">Provider</span> <span class="o">{</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Provider</span>  <span class="o">{</span>
    <span class="n">T</span> <span class="nf">get</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">MembersInjector</span>  <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">injectMembers</span><span class="o">(</span><span class="n">T</span> <span class="n">t</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">static</span>  <span class="n">MembersInjector</span> <span class="nf">noOp</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="o">(</span><span class="n">MembersInjector</span><span class="o">)</span> <span class="n">NoOpMembersInjector</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kd">static</span> <span class="kd">enum</span> <span class="n">NoOpMembersInjector</span> <span class="kd">implements</span> <span class="n">MembersInjector</span> <span class="o">{</span>
    <span class="n">INSTANCE</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">injectMembers</span><span class="o">(</span><span class="n">Object</span> <span class="n">instance</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>

<p>How you have a little task to do: trace visually all steps that will be made by executing this code:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span>    <span class="n">DaggerAppComponent</span><span class="o">.</span><span class="na">builder</span><span class="o">().</span><span class="na">build</span><span class="o">().</span><span class="na">inject</span><span class="o">(</span><span class="n">MainActivity</span><span class="o">.</span><span class="na">this</span><span class="o">);</span>
</code></pre></div>

<p>What is going on here?</p>

<ul>
<li>A statical <code>DaggerAppComponent.builder()</code> call creates a <code>Builder</code> instance;</li>
<li><code>Builder</code> creates an <code>DaggerAppComponent</code> instance;</li>
<li><code>DaggerAppComponent</code> creates a <code>MainActivity_MembersInjector</code> instance;</li>
<li><code>MainActivity_MembersInjector</code> uses <code>PreferencesLogger_Factory</code> to instantiate <code>PreferencesLogger</code> and injects it into <code>MainActivity</code>.</li>
</ul>

<p>OK, at this point you should understand the basics of how Dagger 2 works, it is time to drink some tea. Take a break and continue 15 minutes later. :D</p>

<h1 id="injection-of-third-party-classes">Injection of third-party classes</h1>

<h2 id="a-module-definition">A <em>Module</em> definition</h2>

<p>A <strong>module</strong> is a part of your application that <em>provides</em> some functionality,
while a <strong>component</strong> is a part of your application that <em>consumes</em> some functionality.
You can have any number of modules, for example you can create <code>DatabaseModule</code>, <code>NetworkModule</code>, <code>MainActivityModule</code>, etc.
The same can be said for components.</p>

<p>Let&rsquo;s create our next example around sharing a <code>SharedPreferences</code> object.
At first, we need to somehow say to Dagger how we want to instantiate <code>SharedPreferences</code>.
We obviously can not mark it&rsquo;s constructor with <code>@Inject</code>, so we do this by creation a <strong>Module</strong> class like this:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="nd">@Module</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppModule</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">PREFERENCES_FILE_NAME</span> <span class="o">=</span> <span class="s">&quot;preferences&quot;</span><span class="o">;</span>

    <span class="kd">private</span> <span class="n">MyApplication</span> <span class="n">app</span><span class="o">;</span>

    <span class="n">AppModule</span><span class="o">(</span><span class="n">MyApplication</span> <span class="n">app</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">app</span> <span class="o">=</span> <span class="n">app</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Singleton</span>
    <span class="nd">@Provides</span>
    <span class="n">SharedPreferences</span> <span class="nf">provideSharedPreferences</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">app</span><span class="o">.</span><span class="na">getSharedPreferences</span><span class="o">(</span><span class="n">PREFERENCES_FILE_NAME</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>

<p><code>@Module</code> says to Dagger that this object will be used for objects instantiation.</p>

<p><code>@Provides</code> means that this method should be called to instantiate an object.</p>

<p><code>@Singleton</code> means that the object should be reused for injection into other objects.</p>

<p>Here is a little diagram of how <strong>Module</strong> is being used by Dagger 2:</p>

<p><img src="/images/dagger_2_diagram_2.png" alt="Dagger 2 diagram 2" /></p>

<h2 id="new-preferenceslogger">New <code>PreferencesLogger</code></h2>

<p>Now we do not want to instantiate <code>SharedPreferences</code> inside of <code>PreferencesLogger</code>,
now we can declare it in the <code>PreferencesLogger</code>&rsquo;s constructor and Dagger will supply
constructor with <code>SharedPreferences</code> instance.</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">PreferencesLogger</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="n">SharedPreferences</span> <span class="n">pref</span><span class="o">;</span>

    <span class="nd">@Inject</span>
    <span class="kd">public</span> <span class="nf">PreferencesLogger</span><span class="o">(</span><span class="n">SharedPreferences</span> <span class="n">pref</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">pref</span> <span class="o">=</span> <span class="n">pref</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">log</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">Log</span><span class="o">.</span><span class="na">v</span><span class="o">(</span><span class="n">getClass</span><span class="o">().</span><span class="na">getSimpleName</span><span class="o">(),</span> <span class="s">&quot;Logging all preferences:&quot;</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">Map</span><span class="o">.</span><span class="na">Entry</span> <span class="n">entry</span> <span class="o">:</span> <span class="n">pref</span><span class="o">.</span><span class="na">getAll</span><span class="o">().</span><span class="na">entrySet</span><span class="o">())</span>
            <span class="n">Log</span><span class="o">.</span><span class="na">v</span><span class="o">(</span><span class="n">getClass</span><span class="o">().</span><span class="na">getSimpleName</span><span class="o">(),</span> <span class="n">entry</span><span class="o">.</span><span class="na">getKey</span><span class="o">()</span> <span class="o">+</span> <span class="s">&quot; = &quot;</span> <span class="o">+</span> <span class="n">entry</span><span class="o">.</span><span class="na">getValue</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>

<p>We can go both ways - constructor argument or injectable field. Constructor arguments are usually more handy -
if you inject an object through constructor you can use it right inside that constructor if you wish.</p>

<p>If you have <code>@Inject haredPreferences pref</code> field then Dagger will inject it as well, but only after
constructor&rsquo;s end. This will look like this:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">PreferencesLogger</span> <span class="o">{</span>

    <span class="nd">@Inject</span> <span class="n">SharedPreferences</span> <span class="n">pref</span><span class="o">;</span>

    <span class="nd">@Inject</span>
    <span class="kd">public</span> <span class="nf">PreferencesLogger</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>

    <span class="o">...</span>
</code></pre></div>

<p>Both methods are doing the same thing. Notice that in the second case there is no <code>private</code> modifier -
this is because Dagger will need to access this field to make injection.</p>

<h2 id="new-appcomponent">New <code>AppComponent</code></h2>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="nd">@Singleton</span>
<span class="nd">@Component</span><span class="o">(</span><span class="n">modules</span> <span class="o">=</span> <span class="n">AppModule</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">AppComponent</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">inject</span><span class="o">(</span><span class="n">MainActivity</span> <span class="n">activity</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div>

<p><code>@Singleton</code> says that this component will keep singletons instances inside.</p>

<p><code>(modules = AppModule.class)</code> means that AppModule will be used for injections by AppComponent. You can enumerate several modules here, for example:
<code>(modules = {AppModule.class, MainActivityModule.class})</code></p>

<p>If you want to inject into more than one object with this component you can write something like this:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="nd">@Singleton</span>
<span class="nd">@Component</span><span class="o">(</span><span class="n">modules</span> <span class="o">=</span> <span class="n">AppModule</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">AppComponent</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">inject</span><span class="o">(</span><span class="n">MainActivity</span> <span class="n">activity</span><span class="o">);</span>
    <span class="kt">void</span> <span class="nf">inject</span><span class="o">(</span><span class="n">MainFragment</span> <span class="n">fragment</span><span class="o">);</span>
    <span class="kt">void</span> <span class="nf">inject</span><span class="o">(</span><span class="n">MainToolbarView</span> <span class="n">view</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div>

<h2 id="a-new-appcomponent-instantiation">A new <code>AppComponent</code> instantiation</h2>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span>    <span class="n">component</span> <span class="o">=</span> <span class="n">DaggerAppComponent</span><span class="o">.</span><span class="na">builder</span><span class="o">().</span><span class="na">appModule</span><span class="o">(</span><span class="k">new</span> <span class="n">AppModule</span><span class="o">(</span><span class="k">this</span><span class="o">)).</span><span class="na">build</span><span class="o">();</span>
</code></pre></div>

<p>That&rsquo;s it. Now you know how to use third-party objects with Dagger 2.</p>

<h1 id="magic">Magic</h1>

<h2 id="easier-instantiation-of-component">Easier instantiation of Component</h2>

<p>If you tried to use Dagger 2, then you noticed that IDE can not find <code>DaggerAppComponent</code> and marks it as error
with red color while the project still compiles without errors. Everything should look nice and clean,
so this issue should be somehow avoided.</p>

<p>One possible solution - is to use <a href="https://bitbucket.org/hvisser/android-apt">android-apt</a> plugin.</p>

<p>While surfing GitHub I&rsquo;ve found another interesting solution for this problem
in <a href="https://github.com/square/mortar">Mortar</a> project (I can&rsquo;t give a direct reference to the file - it moves sometimes).
I took <code>buildComponent</code> function that instantiates component
and copied it into my example. <a href="https://github.com/konmik/Dagger2Example/blob/master/app/src/main/java/info/android15/dagger2example/Dagger2Helper.java">Dagger2Helper</a>:</p>

<p>The second solution uses reflection, but it does not create any noticeable performance impact.
On a slowest device that I could get it takes just about 15 ms during application startup time.</p>

<p>Here is how it looks like:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyApplication</span> <span class="kd">extends</span> <span class="n">Application</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="n">AppComponent</span> <span class="n">component</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">();</span>
        <span class="c1">// component = DaggerAppComponent.builder().appModule(new AppModule(this)).build();</span>
        <span class="n">component</span> <span class="o">=</span> <span class="n">Dagger2Helper</span><span class="o">.</span><span class="na">buildComponent</span><span class="o">(</span><span class="n">AppComponent</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="k">new</span> <span class="n">AppModule</span><span class="o">(</span><span class="k">this</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="o">...</span>
</code></pre></div>

<h2 id="easier-injection-inheritance">Easier injection + inheritance</h2>

<p>One tip of how to make injection easier is to change a little bit our injection method.
Instead of writing <code>MyApplication.inject(...)</code> we could write <code>MyApplication.getComponent().inject(...)</code>
so we do not have to bloat <code>MyApplication</code>. You can also extract injector and call <code>MainInjector.getComponent().inject(...)</code>.</p>

<p>Another option relies on reflection, so I will describe it more verbosely.</p>

<p>During good old times of Dagger 1 we had only one <code>void inject(Object object)</code> method.
While it was not so blazing fast it was quite handy. In example, we could write <code>inject(this)</code> in a base class
and all subclasses would get their injections without additional Dagger calls.
It was so handy, so I decided to reproduce such behaviour.</p>

<p>Here is example:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BaseTarget</span> <span class="o">{</span>
    <span class="nd">@Inject</span> <span class="kd">protected</span> <span class="n">MyApplication</span> <span class="n">app</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">BaseTarget</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">Log</span><span class="o">.</span><span class="na">v</span><span class="o">(</span><span class="n">getClass</span><span class="o">().</span><span class="na">getSimpleName</span><span class="o">(),</span> <span class="s">&quot;app before injection: &quot;</span> <span class="o">+</span> <span class="n">app</span><span class="o">);</span>
        <span class="n">MyApplication</span><span class="o">.</span><span class="na">getComponent</span><span class="o">().</span><span class="na">inject</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
        <span class="n">Log</span><span class="o">.</span><span class="na">v</span><span class="o">(</span><span class="n">getClass</span><span class="o">().</span><span class="na">getSimpleName</span><span class="o">(),</span> <span class="s">&quot;app after injection: &quot;</span> <span class="o">+</span> <span class="n">app</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>

<p>To satisfy this dependency I will just add this code to <code>AppModule</code>:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="nd">@Provides</span>
<span class="n">MyApplication</span> <span class="nf">provideApp</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">app</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div>

<p>A subclass that should get injection without direct <code>inject(...)</code> call:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">RealTarget</span> <span class="kd">extends</span> <span class="n">BaseTarget</span> <span class="o">{</span>
    <span class="nd">@Inject</span> <span class="n">SharedPreferences</span> <span class="n">pref</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">RealTarget</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">check</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">Log</span><span class="o">.</span><span class="na">v</span><span class="o">(</span><span class="n">getClass</span><span class="o">().</span><span class="na">getSimpleName</span><span class="o">(),</span> <span class="s">&quot;Base injection app: &quot;</span> <span class="o">+</span> <span class="n">app</span><span class="o">);</span>
        <span class="n">Log</span><span class="o">.</span><span class="na">v</span><span class="o">(</span><span class="n">getClass</span><span class="o">().</span><span class="na">getSimpleName</span><span class="o">(),</span> <span class="s">&quot;Real injection pref: &quot;</span> <span class="o">+</span> <span class="n">pref</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>

<p>Calling <code>new RealTarget().check()</code> produces the following output:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>app before injection: null
app after injection: info.android15.dagger2example.MyApplication@419412e0
Base injection app: info.android15.dagger2example.MyApplication@419412e0
Real injection pref: null
</code></pre></div>

<p>As you can see, subclass dependency <code>SharedPreferences</code> has not been satisfied because the classical
Dagger 2 usage pattern implies that you should call <code>inject(...)</code> on a <code>RealTarget</code>.
If you like to create things like <code>BaseActivity</code>, <code>BaseCustomView</code>, <code>BaseAdapter</code>, etc, this can not be satisfying.</p>

<p>Now I will use <code>inject</code> function that has been made to reproduce Dagger1 easy injections through a superclass:
<a href="https://github.com/konmik/Dagger2Example/blob/master/app/src/main/java/info/android15/dagger2example/Dagger2Helper.java">Dagger2Helper</a>:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyApplication</span> <span class="kd">extends</span> <span class="n">Application</span> <span class="o">{</span>

    <span class="o">...</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">inject</span><span class="o">(</span><span class="n">Object</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Dagger2Helper</span><span class="o">.</span><span class="na">inject</span><span class="o">(</span><span class="n">AppComponent</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">component</span><span class="o">,</span> <span class="n">target</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BaseTarget</span> <span class="o">{</span>
    <span class="nd">@Inject</span> <span class="kd">protected</span> <span class="n">MyApplication</span> <span class="n">app</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">BaseTarget</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">Log</span><span class="o">.</span><span class="na">v</span><span class="o">(</span><span class="n">getClass</span><span class="o">().</span><span class="na">getSimpleName</span><span class="o">(),</span> <span class="s">&quot;app before injection: &quot;</span> <span class="o">+</span> <span class="n">app</span><span class="o">);</span>
        <span class="c1">// MyApplication.getComponent().inject(this);</span>
        <span class="n">MyApplication</span><span class="o">.</span><span class="na">inject</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
        <span class="n">Log</span><span class="o">.</span><span class="na">v</span><span class="o">(</span><span class="n">getClass</span><span class="o">().</span><span class="na">getSimpleName</span><span class="o">(),</span> <span class="s">&quot;app after injection: &quot;</span> <span class="o">+</span> <span class="n">app</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>

<p>Output:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>app before injection: null
app after injection: info.android15.dagger2example.MyApplication@419430e0
Base injection app: info.android15.dagger2example.MyApplication@419430e0
Real injection pref: android.app.SharedPreferencesImpl@419630d8
</code></pre></div>

<p>Hurray! Easy injections through a base class! Yeh, but what is their price?
I said &ldquo;reflection&rdquo; so I need to prove that it will not degrade the performance.</p>

<h4 id="14-07-2015-update">14.07.2015 update:</h4>

<p>I finally came with a better solution for injection through inheritance:
<a href="https://gist.github.com/konmik/6ac725fa7134402539c4">ComponentReflectionDelegate</a></p>

<p>Use it with <a href="https://bitbucket.org/hvisser/android-apt">APT</a> plugin to remove errors in IDE.</p>

<h2 id="performance">Performance</h2>

<p>For performance benchmarks I used Galaxy S - an android device of year 2010.
I also created 50-method Component class to make reflection run slower.
While this benchmark can not be exact because of processor cache hits and JIT,
the difference should not be large.</p>

<p>A direct injection on a subclass takes about 0.0013 ms,
a reflected injection on a superclass takes about 0.014 ms.
Both prices are negligible.</p>

<p>For a comparison, one frame of 60 FPS animation takes 16 ms. You can make 100 reflected injections or 1000 direct injections
EVERY frame during the scroll time and the user will never see the difference even on a slowest device.
Typically we do not inject during scrolling - this is something we do during loading, so we can consider Dagger 2 injection to be free.</p>

<h1 id="example-code">Example code</h1>

<p>Example code is available at <a href="https://github.com/konmik/Dagger2Example">GitHub/konmik/Dagger2Example</a></p>
  </section>
</article>

</main>


</div>

<footer>
  <div class="container">
    <span class="copyright">&copy; 2015  Konstantin Mikheev&#39;s programming blog</span>
  </div>
</footer>

</body>
</html>

